{
  "version": 3,
  "sources": ["../../../src/utils/common/compUtils.ts"],
  "sourcesContent": ["import { useGlobSetting } from '/@/hooks/setting';\nimport { merge, random } from 'lodash-es';\nimport { isArray } from '/@/utils/is';\nimport { FormSchema } from '/@/components/Form';\n\nconst globSetting = useGlobSetting();\nconst baseApiUrl = globSetting.domainUrl;\n/**\n *  \u83B7\u53D6\u6587\u4EF6\u670D\u52A1\u8BBF\u95EE\u8DEF\u5F84\n * @param fileUrl \u6587\u4EF6\u8DEF\u5F84\n * @param prefix(\u9ED8\u8BA4http)  \u6587\u4EF6\u8DEF\u5F84\u524D\u7F00 http/https\n */\nexport const getFileAccessHttpUrl = (fileUrl, prefix = 'http') => {\n  let result = fileUrl;\n  try {\n    if (fileUrl && fileUrl.length > 0 && !fileUrl.startsWith(prefix)) {\n      //\u5224\u65AD\u662F\u5426\u662F\u6570\u7EC4\u683C\u5F0F\n      let isArray = fileUrl.indexOf('[') != -1;\n      if (!isArray) {\n        let prefix = `${baseApiUrl}/sys/common/static/`;\n        // \u5224\u65AD\u662F\u5426\u5DF2\u5305\u542B\u524D\u7F00\n        if (!fileUrl.startsWith(prefix)) {\n          result = `${prefix}${fileUrl}`;\n        }\n      }\n    }\n  } catch (err) {}\n  return result;\n};\n\n/**\n * \u89E6\u53D1 window.resize\n */\nexport function triggerWindowResizeEvent() {\n  let event: any = document.createEvent('HTMLEvents');\n  event.initEvent('resize', true, true);\n  event.eventType = 'message';\n  window.dispatchEvent(event);\n}\n\n/**\n * \u83B7\u53D6\u968F\u673A\u6570\n *  @param length \u6570\u5B57\u4F4D\u6570\n */\nexport const getRandom = (length: number = 1) => {\n  return '-' + parseInt(String(Math.random() * 10000 + 1), length);\n};\n\n/**\n * \u968F\u673A\u751F\u6210\u5B57\u7B26\u4E32\n * @param length \u5B57\u7B26\u4E32\u7684\u957F\u5EA6\n * @param chats \u53EF\u9009\u5B57\u7B26\u4E32\u533A\u95F4\uFF08\u53EA\u4F1A\u751F\u6210\u4F20\u5165\u7684\u5B57\u7B26\u4E32\u4E2D\u7684\u5B57\u7B26\uFF09\n * @return string \u751F\u6210\u7684\u5B57\u7B26\u4E32\n */\nexport function randomString(length: number, chats?: string) {\n  if (!length) length = 1;\n  if (!chats) {\n    // noinspection SpellCheckingInspection\n    chats = '0123456789qwertyuioplkjhgfdsazxcvbnm';\n  }\n  let str = '';\n  for (let i = 0; i < length; i++) {\n    let num = random(0, chats.length - 1);\n    str += chats[num];\n  }\n  return str;\n}\n\n/**\n * \u5C06\u666E\u901A\u5217\u8868\u6570\u636E\u8F6C\u5316\u4E3Atree\u7ED3\u6784\n * @param array tree\u6570\u636E\n * @param opt  \u914D\u7F6E\u53C2\u6570\n * @param startPid \u7236\u8282\u70B9\n */\nexport const listToTree = (array, opt, startPid) => {\n  const obj = {\n    primaryKey: opt.primaryKey || 'key',\n    parentKey: opt.parentKey || 'parentId',\n    titleKey: opt.titleKey || 'title',\n    startPid: opt.startPid || '',\n    currentDept: opt.currentDept || 0,\n    maxDept: opt.maxDept || 100,\n    childKey: opt.childKey || 'children',\n  };\n  if (startPid) {\n    obj.startPid = startPid;\n  }\n  return toTree(array, obj.startPid, obj.currentDept, obj);\n};\n/**\n *  \u9012\u5F52\u6784\u5EFAtree\n * @param list\n * @param startPid\n * @param currentDept\n * @param opt\n * @returns {Array}\n */\nexport const toTree = (array, startPid, currentDept, opt) => {\n  if (opt.maxDept < currentDept) {\n    return [];\n  }\n  let child = [];\n  if (array && array.length > 0) {\n    child = array\n      .map((item) => {\n        // \u7B5B\u67E5\u7B26\u5408\u6761\u4EF6\u7684\u6570\u636E\uFF08\u4E3B\u952E = startPid\uFF09\n        if (typeof item[opt.parentKey] !== 'undefined' && item[opt.parentKey] === startPid) {\n          // \u6EE1\u8DB3\u6761\u4EF6\u5219\u9012\u5F52\n          const nextChild = toTree(array, item[opt.primaryKey], currentDept + 1, opt);\n          // \u8282\u70B9\u4FE1\u606F\u4FDD\u5B58\n          if (nextChild.length > 0) {\n            item['isLeaf'] = false;\n            item[opt.childKey] = nextChild;\n          } else {\n            item['isLeaf'] = true;\n          }\n          item['title'] = item[opt.titleKey];\n          item['label'] = item[opt.titleKey];\n          item['key'] = item[opt.primaryKey];\n          item['value'] = item[opt.primaryKey];\n          return item;\n        }\n      })\n      .filter((item) => {\n        return item !== undefined;\n      });\n  }\n  return child;\n};\n\n/**\n * \u8868\u683C\u5E95\u90E8\u5408\u8BA1\u5DE5\u5177\u65B9\u6CD5\n * @param tableData \u8868\u683C\u6570\u636E\n * @param fieldKeys \u8981\u8BA1\u7B97\u5408\u8BA1\u7684\u5217\u5B57\u6BB5\n */\nexport function mapTableTotalSummary(tableData: Recordable[], fieldKeys: string[]) {\n  let totals: any = { _row: '\u5408\u8BA1', _index: '\u5408\u8BA1' };\n  fieldKeys.forEach((key) => {\n    totals[key] = tableData.reduce((prev, next) => {\n      prev += next[key];\n      return prev;\n    }, 0);\n  });\n  return totals;\n}\n\n/**\n * \u7B80\u5355\u5B9E\u73B0\u9632\u6296\u65B9\u6CD5\n *\n * \u9632\u6296(debounce)\u51FD\u6570\u5728\u7B2C\u4E00\u6B21\u89E6\u53D1\u7ED9\u5B9A\u7684\u51FD\u6570\u65F6\uFF0C\u4E0D\u7ACB\u5373\u6267\u884C\u51FD\u6570\uFF0C\u800C\u662F\u7ED9\u51FA\u4E00\u4E2A\u671F\u9650\u503C(delay)\uFF0C\u6BD4\u5982100ms\u3002\n * \u5982\u679C100ms\u5185\u518D\u6B21\u6267\u884C\u51FD\u6570\uFF0C\u5C31\u91CD\u65B0\u5F00\u59CB\u8BA1\u65F6\uFF0C\u76F4\u5230\u8BA1\u65F6\u7ED3\u675F\u540E\u518D\u771F\u6B63\u6267\u884C\u51FD\u6570\u3002\n * \u8FD9\u6837\u505A\u7684\u597D\u5904\u662F\u5982\u679C\u77ED\u65F6\u95F4\u5185\u5927\u91CF\u89E6\u53D1\u540C\u4E00\u4E8B\u4EF6\uFF0C\u53EA\u4F1A\u6267\u884C\u4E00\u6B21\u51FD\u6570\u3002\n *\n * @param fn \u8981\u9632\u6296\u7684\u51FD\u6570\n * @param delay \u9632\u6296\u7684\u6BEB\u79D2\u6570\n * @returns {Function}\n */\nexport function simpleDebounce(fn, delay = 100) {\n  let timer: any | null = null;\n  return function () {\n    let args = arguments;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      // @ts-ignore\n      fn.apply(this, args);\n    }, delay);\n  };\n}\n\n/**\n * \u65E5\u671F\u683C\u5F0F\u5316\n * @param date \u65E5\u671F\n * @param block \u683C\u5F0F\u5316\u5B57\u7B26\u4E32\n */\nexport function dateFormat(date, block) {\n  if (!date) {\n    return '';\n  }\n  let format = block || 'yyyy-MM-dd';\n  date = new Date(date);\n  const map = {\n    M: date.getMonth() + 1, // \u6708\u4EFD\n    d: date.getDate(), // \u65E5\n    h: date.getHours(), // \u5C0F\u65F6\n    m: date.getMinutes(), // \u5206\n    s: date.getSeconds(), // \u79D2\n    q: Math.floor((date.getMonth() + 3) / 3), // \u5B63\u5EA6\n    S: date.getMilliseconds(), // \u6BEB\u79D2\n  };\n  format = format.replace(/([yMdhmsqS])+/g, (all, t) => {\n    let v = map[t];\n    if (v !== undefined) {\n      if (all.length > 1) {\n        v = `0${v}`;\n        v = v.substr(v.length - 2);\n      }\n      return v;\n    } else if (t === 'y') {\n      return date\n        .getFullYear()\n        .toString()\n        .substr(4 - all.length);\n    }\n    return all;\n  });\n  return format;\n}\n\n/**\n * \u83B7\u53D6\u4E8B\u4EF6\u5192\u6CE1\u8DEF\u5F84\uFF0C\u517C\u5BB9 IE11\uFF0CEdge\uFF0CChrome\uFF0CFirefox\uFF0CSafari\n * \u76EE\u524D\u4F7F\u7528\u7684\u5730\u65B9\uFF1AJVxeTable Span\u6A21\u5F0F\n */\nexport function getEventPath(event) {\n  let target = event.target;\n  let path = (event.composedPath && event.composedPath()) || event.path;\n\n  if (path != null) {\n    return path.indexOf(window) < 0 ? path.concat(window) : path;\n  }\n\n  if (target === window) {\n    return [window];\n  }\n\n  let getParents = (node, memo) => {\n    const parentNode = node.parentNode;\n\n    if (!parentNode) {\n      return memo;\n    } else {\n      return getParents(parentNode, memo.concat(parentNode));\n    }\n  };\n  return [target].concat(getParents(target, []), window);\n}\n\n/**\n * \u5982\u679C\u503C\u4E0D\u5B58\u5728\u5C31 push \u8FDB\u6570\u7EC4\uFF0C\u53CD\u4E4B\u4E0D\u5904\u7406\n * @param array \u8981\u64CD\u4F5C\u7684\u6570\u636E\n * @param value \u8981\u6DFB\u52A0\u7684\u503C\n * @param key \u53EF\u7A7A\uFF0C\u5982\u679C\u6BD4\u8F83\u7684\u662F\u5BF9\u8C61\uFF0C\u53EF\u80FD\u5B58\u5728\u5730\u5740\u4E0D\u4E00\u6837\u4F46\u503C\u5B9E\u9645\u4E0A\u662F\u4E00\u6837\u7684\u60C5\u51B5\uFF0C\u53EF\u4EE5\u4F20\u6B64\u5B57\u6BB5\u5224\u65AD\u5BF9\u8C61\u4E2D\u552F\u4E00\u7684\u5B57\u6BB5\uFF0C\u4F8B\u5982 id\u3002\u4E0D\u4F20\u5219\u76F4\u63A5\u6BD4\u8F83\u5B9E\u9645\u503C\n * @returns {boolean} \u6210\u529F push \u8FD4\u56DE true\uFF0C\u4E0D\u5904\u7406\u8FD4\u56DE false\n */\nexport function pushIfNotExist(array, value, key?) {\n  for (let item of array) {\n    if (key && item[key] === value[key]) {\n      return false;\n    } else if (item === value) {\n      return false;\n    }\n  }\n  array.push(value);\n  return true;\n}\n/**\n * \u8FC7\u6EE4\u5BF9\u8C61\u4E2D\u4E3A\u7A7A\u7684\u5C5E\u6027\n * @param obj\n * @returns {*}\n */\nexport function filterObj(obj) {\n  if (!(typeof obj == 'object')) {\n    return;\n  }\n\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key) && (obj[key] == null || obj[key] == undefined || obj[key] === '')) {\n      delete obj[key];\n    }\n  }\n  return obj;\n}\n\n/**\n * \u4E0B\u5212\u7EBF\u8F6C\u9A7C\u5CF0\n * @param string\n */\nexport function underLine2CamelCase(string: string) {\n  return string.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\n/**\n * \u67E5\u627E\u6811\u7ED3\u6784\n * @param treeList\n * @param fn \u67E5\u627E\u65B9\u6CD5\n * @param childrenKey\n */\nexport function findTree(treeList: any[], fn: Fn, childrenKey = 'children') {\n  for (let i = 0; i < treeList.length; i++) {\n    let item = treeList[i];\n    if (fn(item, i, treeList)) {\n      return item;\n    }\n    let children = item[childrenKey];\n    if (isArray(children)) {\n      let findResult = findTree(children, fn, childrenKey);\n      if (findResult) {\n        return findResult;\n      }\n    }\n  }\n  return null;\n}\n\n/** \u83B7\u53D6 mapFormSchema \u65B9\u6CD5 */\nexport function bindMapFormSchema<T>(spanMap, spanTypeDef: T) {\n  return function (s: FormSchema, spanType: T = spanTypeDef) {\n    return merge(\n      {\n        disabledLabelWidth: true,\n      } as FormSchema,\n      spanMap[spanType],\n      s\n    );\n  };\n}\n\n/**\n * \u5B57\u7B26\u4E32\u662F\u5426\u4E3Anull\u6216null\u5B57\u7B26\u4E32\n * @param str\n * @return {boolean}\n */\nexport function stringIsNull(str) {\n  // \u4E24\u4E2A == \u53EF\u4EE5\u540C\u65F6\u5224\u65AD null \u548C undefined\n  return str == null || str === 'null' || str === 'undefined';\n}\n"],
  "mappings": ";;;;;;;;;;;;AAAA;AAKA,IAAM,cAAc,eAAe;AACnC,IAAM,aAAa,YAAY;AAMxB,IAAM,uBAAuB,CAAC,SAAS,SAAS,WAAW;AAChE,MAAI,SAAS;AACb,MAAI;AACF,QAAI,WAAW,QAAQ,SAAS,KAAK,CAAC,QAAQ,WAAW,MAAM,GAAG;AAEhE,UAAIA,WAAU,QAAQ,QAAQ,GAAG,KAAK;AACtC,UAAI,CAACA,UAAS;AACZ,YAAIC,UAAS,GAAG;AAEhB,YAAI,CAAC,QAAQ,WAAWA,OAAM,GAAG;AAC/B,mBAAS,GAAGA,UAAS;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF,SAAS,KAAP;AAAA,EAAa;AACf,SAAO;AACT;AA0BO,SAAS,aAAa,QAAgB,OAAgB;AAC3D,MAAI,CAAC;AAAQ,aAAS;AACtB,MAAI,CAAC,OAAO;AAEV,YAAQ;AAAA,EACV;AACA,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,QAAI,MAAM,eAAO,GAAG,MAAM,SAAS,CAAC;AACpC,WAAO,MAAM;AAAA,EACf;AACA,SAAO;AACT;AA2FO,SAAS,eAAe,IAAI,QAAQ,KAAK;AAC9C,MAAI,QAAoB;AACxB,SAAO,WAAY;AACjB,QAAI,OAAO;AACX,QAAI,OAAO;AACT,mBAAa,KAAK;AAAA,IACpB;AACA,YAAQ,WAAW,MAAM;AAEvB,SAAG,MAAM,MAAM,IAAI;AAAA,IACrB,GAAG,KAAK;AAAA,EACV;AACF;AA4FO,SAAS,UAAU,KAAK;AAC7B,MAAI,EAAE,OAAO,OAAO,WAAW;AAC7B;AAAA,EACF;AAEA,WAAS,OAAO,KAAK;AACnB,QAAI,IAAI,eAAe,GAAG,MAAM,IAAI,QAAQ,QAAQ,IAAI,QAAQ,UAAa,IAAI,SAAS,KAAK;AAC7F,aAAO,IAAI;AAAA,IACb;AAAA,EACF;AACA,SAAO;AACT;AAMO,SAAS,oBAAoB,QAAgB;AAClD,SAAO,OAAO,QAAQ,aAAa,CAAC,GAAG,WAAW,OAAO,YAAY,CAAC;AACxE;AA0BO,SAAS,kBAAqB,SAAS,aAAgB;AAC5D,SAAO,SAAU,GAAe,WAAc,aAAa;AACzD,WAAO;AAAA,MACL;AAAA,QACE,oBAAoB;AAAA,MACtB;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;",
  "names": ["isArray", "prefix"]
}
